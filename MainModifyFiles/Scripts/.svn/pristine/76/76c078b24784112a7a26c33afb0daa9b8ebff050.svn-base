// **********************************************************************
// Copyright (c) 2013 Baoyugame. All rights reserved.
// File     :  SingleMicrophoneCapture.cs
// Author   : willson
// Created  : 2014/12/8 
// Porpuse  : 
// **********************************************************************
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18063
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using Qiniu.RS;
using Qiniu.Auth.digest;
using Qiniu.Conf;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using com.nucleus.commons.message;
using System.IO;

public class VoiceRecognitionManager : MonoBehaviour 
{
	private static VoiceRecognitionManager _instance = null;
	public static VoiceRecognitionManager Instance
	{
		get
		{
			CreateInstance();
			return _instance;
		}
	}
	
	static void CreateInstance()
	{
		if (_instance == null)
		{
			_instance = GameObject.FindObjectOfType(typeof(VoiceRecognitionManager)) as VoiceRecognitionManager;
			
			if (_instance == null)
			{
				GameObject go = new GameObject("_SingleMicrophoneCapture");
				DontDestroyOnLoad(go);
				_instance = go.AddComponent<VoiceRecognitionManager>();
				_instance.Init();
				_instance.InitUpToken();
			}
		}
	}

	public void Setup()
	{
		BaiduVoiceRecognition.Instance.getToken();
	}

	private string _uptoken;

	public void InitUpToken()
	{
		/*
		ServiceRequestAction.requestServer(ChatService.uptoken(),"", 
			delegate(GeneralResponse e) 
		    {
				VoiceTokenDto dto = e as VoiceTokenDto;
				_uptoken = dto.token;
			}
		);
		*/
	}

	public string GetUpToken()
	{
		return _uptoken;
	}

	// 是否有麦克风
	private bool _micConnected = false;
	private bool _isRecord = false;

	private int _minFreq;
	private int _maxFreq;
	
	private AudioSource _recordAudioSource;
	
	private AudioSource _playAudioSource;
	private AudioClip _qiniuVoice;
	
	//已经翻译好的语音 , key是filename , vlaue是翻译好的文字//
	private Dictionary< string , string > _translatedSourceDic = new Dictionary<string, string>();
	//已经下载好的语音，最大个数与聊天信息里面的最大个数一直，key是filename ， value是下载的好audiosoucre//
	private Dictionary< string , AudioClip > _downLoaderSourceDic = new Dictionary<string, AudioClip>();

	private void Init()
	{
		if(Microphone.devices.Length <= 0)
		{
			Debug.LogWarning("Microphone not connected!");
		}
		else
		{
			_micConnected = true;
			Microphone.GetDeviceCaps(null, out _minFreq, out _maxFreq);
			// 百度只能处理 8000 的音频信息
			if(_minFreq == 0 && _maxFreq == 0)
			{
				_maxFreq = 8000;
			}
			else if(_maxFreq != 8000)
			{
				_maxFreq = 8000;
			}
			
			_recordAudioSource = this.gameObject.AddComponent<AudioSource>();
			_playAudioSource = this.gameObject.AddComponent<AudioSource>();
		}
	}

	public bool IsMicConnected()
	{
		return _micConnected;
	}

	private Action _callBackRecordFinish = null;
	private int    _maxRecordTime = 15 ;
	public void Record( Action callBackRecordFinish = null )
	{
		_callBackRecordFinish = callBackRecordFinish;
		if(_micConnected && _recordAudioSource != null)
		{
			AudioManager.Instance.StopVolumeWhenRecordVoice();

			_isRecord = true;
			_recordAudioSource.clip = Microphone.Start(null, true, _maxRecordTime, _maxFreq );
			while( !(Microphone.GetPosition( null ) > 0 )) {};

			_recordAudioSource.volume = 0;
			_recordAudioSource.Play();
			_recordTime = 0 ;
			CoolDownManager.Instance.SetupCoolDown( "voiceRecordTime" , ( float )_maxRecordTime , OnUpdateRecordTime , OnRecordTimeFinished );
		}
	}

	public void Stop()
	{
		if(_micConnected && _recordAudioSource != null)
		{
			_isRecord = false;
			Microphone.End(null); 
			// debug TipManager.AddTip("停止录音");

			AudioManager.Instance.PlayVoiceWhenFinishRecord();

			CoolDownManager.Instance.CancelCoolDown( "voiceRecordTime" );

			int lengthSample = Mathf.CeilToInt( _maxFreq * _recordTime * _recordAudioSource.clip.channels  );
			float[] samplesBuf = new float[ lengthSample ];
			_recordAudioSource.clip.GetData( samplesBuf , 0 );
			if( lengthSample > 0 )
			{
				AudioClip clip = AudioClip.Create( "clip" , lengthSample , _recordAudioSource.clip.channels , _maxFreq , false ,false  );
				clip.SetData( samplesBuf , 0 );
				_recordAudioSource.clip = clip;
			}


		}
	}

	public bool IsRecord()
	{
		return _isRecord;
	}

	/*
	 * 计算录制的时长
	 */
	private int _recordTime = 0;
	void OnUpdateRecordTime( float time )
	{
		_recordTime++;
	}
	
	/*
	 * 最长录音计时结束
	 */
	void OnRecordTimeFinished()
	{
		if( _recordTime > _maxRecordTime )
		{
			_recordTime = _maxRecordTime;
		}
		if( _callBackRecordFinish != null )
		{
			TipManager.AddTip( string.Format  ( "最长只能录制{0}秒的音频" , _maxRecordTime ) );
			_callBackRecordFinish();
		}
	}


	/*
	 * 判断当前录制的语音时间是否够长，不够钱则不发送
	 */
	public bool IsEnoughLength()
	{
		if( _recordAudioSource != null )
		{
			if( _recordTime > 1 )
			{
				return true;
			}
			else
			{
				TipManager.AddTip( "语音录制太短" );
				return false;
			}
		}
		return false ;
	}

	public void PlayRecord()
	{
		if(_recordAudioSource != null)
			_recordAudioSource.Play(); //Playback the recorded audio
	}

	public void GetVoiceText(byte[] amrBuf,int amrBufSize,System.Action<string> callBack)
	{
		if(_recordAudioSource != null && amrBufSize > 0)
		{
			BaiduVoiceRecognition.Instance.GetVoiceText(amrBuf,amrBufSize,callBack);
		}
	}

	public string SaveVoiceToQiniu( byte[] amrBuf ,int amrBufSize,string key = "")
	{
		QiniuFile amrFile = new QiniuFile();
		if(amrBuf != null && amrBuf.Length > 0)
		{
			return amrFile.PutAmrBuf( amrBuf, amrBufSize, key);
		}
		return "";
	}
	
	public void GetVoiceInQiniu(string fileName,System.Action< AudioClip > callBack)
	{
		string url = GetPolicy.MakeBaseUrl(QiniuFile.DOMAIN, fileName);
		string actual = GetPolicy.MakeRequest(url, 3600, new Mac(Config.ACCESS_KEY, Config.Encoding.GetBytes(Config.SECRET_KEY)));
		//TipManager.AddWhiteTip( string.Format( "fileName : {0}" , fileName  )  );
        GameDebuger.Log(string.Format("actual : {0}", actual));
		if( GetSoundMessageByQiniuFileName( fileName ) != null )
		{
			//TipManager.AddWhiteTip( "已经从缓存中获取音频剪辑" );
			if( callBack != null )
			{
				callBack( GetSoundMessageByQiniuFileName( fileName ) );
			}
		} 
		else
		{
			/*
			ServiceRequestAction.requestServer(ChatService.downloadToken(fileName),"", 
				delegate(GeneralResponse e) 
				{
					VoiceTokenDto dto = e as VoiceTokenDto;
					string actual = dto.token;//GetPolicy.MakeRequest(url, 3600, dto.token);
					*/
					StartCoroutine(LoadSound(actual,callBack , fileName));
					/*
				}
			);
			*/
		}

	}

	IEnumerator LoadSound(string path,System.Action<AudioClip> callBack , string fileName )
	{
		WWW amrWWW = new WWW (path);
		yield return amrWWW;
		
		if( amrWWW.isDone && amrWWW.error == null )
		{
			string filePath = Application.persistentDataPath + "/talk/";
			Debug.Log(filePath);
			if(!Directory.Exists(filePath))
			{
				Directory.CreateDirectory(filePath);//创建新路径
			}

			byte[] amrBuf = amrWWW.bytes;

			filePath = filePath + fileName;
			HzamrPlugin.AmrToWavFile(filePath,amrBuf,amrBuf.Length);

#if UNITY_EDITOR || UNITY_STANDALONE_WIN || UNITY_WP8
			WWW wavWWW = new WWW("file:///" + filePath);
#else
			WWW wavWWW = new WWW("file://" + filePath);
#endif

			yield return wavWWW;

			AudioClip tempClip = wavWWW.GetAudioClip( true , false , AudioType.WAV );
			tempClip.name = name;
			SaveSoundMessageWhichDownLoaded( fileName , tempClip );

			if( callBack != null )
			{
				callBack( tempClip );
			}
			//TipManager.AddTip( "已经从服务器获取到了音频" );
		}
		else
		{
			TipManager.AddTip( "该音频无法加载" );
			//Debug.Log (wavWWW.error);
            GameDebuger.Log(path + ",该音频无法加载: " + amrWWW.error + "  , " + fileName);
		}
	}

	public void PlayQiniuSound()
	{
		if(_playAudioSource != null)
		{
			_playAudioSource.clip = _qiniuVoice;
			_playAudioSource.volume = 1f;
			_playAudioSource.loop = false;
			_playAudioSource.Play();
		}
	}

	/*
	 * 根据音频裁剪集播放一下音频
	 */
	public void PlayQiniuSoundByClip( AudioClip clip )
	{
		if( _playAudioSource == null )	return;

		//PlayBGMusic();
		AudioManager.Instance.StopVolumeWhenRecordVoice();

		//TipManager.AddWhiteTip( "音频剪辑准备好了，开始播放！" );
		_playAudioSource.clip = clip;
		_playAudioSource.volume = 1f;
		_playAudioSource.loop = false;
		_playAudioSource.Play();

		//先将声音设置成正常的音量//
		int tempTime = Mathf.CeilToInt( clip.length  )  ;
		GameDebuger.Log("语音长度: " + tempTime);
		CoolDownManager.Instance.SetupCoolDown( "PlayBGMusic" , tempTime/10f , null , PlayBGMusic );
	}

	void PlayBGMusic()
	{
		AudioManager.Instance.PlayVoiceWhenFinishRecord();
	}



	/*
	 * 将自己录制的音频传给七牛服务器并返回文件表示名（key）
	 */
	public void SendSoundToQiNiuAndGetFileKey( Action< byte[],int,string > callbackFinish  )
	{
		VoiceKeyDelegate keyDelegate = new VoiceKeyDelegate();
		keyDelegate.GetKeyThread( callbackFinish, _recordAudioSource.clip );
	}
	

	/*
	 * 接收到翻译好的文本后，根据音频文件名将转译好的文本保存起来
	 */
	public void SaveSoundMessageWhichDownLoaded ( string keyStr , AudioClip downloadS )
	{
		if( _downLoaderSourceDic.Count >= ChatModel.Instance._maxMessageCount )
		{
			string firstKey = string.Empty;
			foreach( KeyValuePair< string , AudioClip > keyValue in _downLoaderSourceDic )
			{
				firstKey = keyValue.Key;
				break;
			}
			_downLoaderSourceDic.Remove ( firstKey );
		}
		if( !_downLoaderSourceDic.ContainsKey( keyStr ) )
		{
			_downLoaderSourceDic.Add( keyStr , downloadS );
		}
	}

	/*
	 * 检索一下本地是否有已经转译好的文本
	 */
	public AudioClip GetSoundMessageByQiniuFileName( string fileName )
	{
		if( _downLoaderSourceDic.ContainsKey( fileName ) )
		{
			return _downLoaderSourceDic[ fileName ];
		}
		return null;
	}

	/*
	 * 提供一个接口，当自己录制的语音上传完之后，存储在缓存的链表中，避免自己听自己音频时再一次请求服务器而消耗流量
	 */
	public void SaveSelfVoiceInList( string fileName  )
	{
		if( _recordAudioSource != null )
		{
			_downLoaderSourceDic.Add( fileName , _recordAudioSource.clip );
		}
	}


	#region 说话时的能量值计算
	public float sensitivity = 100;
	public float sourceVolume = 100;//Between 0 and 100private int amountSamples = 256; //increase to get better 
	private int amountSamples = 256;
	
	
	public float GetVoiceAveraged()
	{
		float loudness = 0;
		if( _isRecord )
		{
			loudness = GetAveragedVolume() * sensitivity ; 
			loudness = loudness > 1? (loudness % 1 ):loudness;
		}
		return loudness;
	}
	
	
	
	float GetAveragedVolume() {
		float[] data = new float[amountSamples];
		float a = 0;
		_recordAudioSource.GetOutputData(data,0);
		foreach(float s in data) {
			a += Mathf.Abs(s);
		}
		return a/amountSamples;
	}
	
	#endregion

	#region 开始录音
	/// <summary>
	/// Begins the record.
	/// callBackMaxRecordFinish 为最长时限录制语音到了之后的回调，用于做界面的处理
	/// </summary>
	/// <param name="callBackRecordFinish">Call back record finish.</param>
	public void BeginRecord( Action callBackMaxRecordFinish = null )
	{
		if(!_isRecord )
		{
//			TipManager.AddTip("开始录音");
			Record( callBackMaxRecordFinish );
		}
	}
	#endregion

	#region 如果手指松开,取消发送
	public bool isDragOut = false;
	//划出去
	public void FingersDragOut(){
		isDragOut = true;

	}


	//划进来
	public void FingersDragOver(){
		isDragOut = false;
	}
	#endregion



	#region 录音结束
	/// <summary>
	/// Finishs the record.
	/// callBackTalkMessage 录制完之后，返回百度已经转译好的文字
	/// </summary>
	/// <param name="">.</param>
	/// <param name="isTimeOut"> 等待百度翻译超时将自动发送语音转文字失败</para>
	/// <param name="isReceive"> 在10s内如果百度翻译回来就发送百度的,10s后的自动转发失败的取消发送</para>
	Dictionary<string,bool> isTimeOutDic = new Dictionary<string, bool>();
	Dictionary<string,bool> isReceiveDic = new Dictionary<string, bool>();
	public void FinishRecord( Action< string,string > callBackTalkMessage ,Action< string > callBackTalkTranslate,Action callBackToShort)
	{
		if( _isRecord )
		{
			Stop();
			
			//判断录制的语音是否太短，如果太短则不执行下去//
			if( !IsEnoughLength()){
				callBackToShort();
				return ;
			}

			//如果手指不是划开后松开的，就继续执行
			if(!isDragOut){
				// debug TipManager.AddTip("保存到七牛");
				SendSoundToQiNiuAndGetFileKey( delegate(byte[] amrBuf,int amrBufSize,string tempobj) {
					string qiniuFileName = tempobj;
					SaveSelfVoiceInList(qiniuFileName);
					string time = PlayerModel.Instance.GetPlayerId() + "-"+System.DateTime.Now.Ticks.ToString();
					string _tBaiduMsg = string.Format( "#*#{0}#*#{1}",qiniuFileName , "" );
					string _tempMsg= ChatModel.Instance.PieceTypeAndContent( ChatMessageFunctionType.VoiceTalk , _tBaiduMsg );
					callBackTalkMessage( _tempMsg,time );
					
//					TipManager.AddTip("已存");
					//等待十秒
					isTimeOutDic.Add(time,false);
					isReceiveDic.Add(time,false);
					
					ChatModel.Instance.SetCoolDownReturnName(time,10f,delegate(string name) {
						
						isTimeOutDic[name] = true;
						if(!isReceiveDic[time]){
							string _tBaiduMsg1 = string.Format( "#*#{0}#*#{1}",qiniuFileName , "语音转文字失败" );
							string _tempMsg1= ChatModel.Instance.PieceTypeAndContent( ChatMessageFunctionType.VoiceTalk , _tBaiduMsg1 );
							callBackTalkTranslate(_tempMsg1);
							//TipManager.AddTip("10秒内没返回");

							//重置为false初始状态
							FingersDragOver();
						}
					});
					
					
					if( !string.IsNullOrEmpty( qiniuFileName ) )
					{
						GetVoiceText(amrBuf,amrBufSize,delegate(string obj) {
							string frontStr = obj.Substring( 0 , obj.Length -1 );
							string lastChar = obj.Substring( obj.Length -1 , 1 );
							if( lastChar.Equals("，") ) lastChar = "";
							obj = frontStr + lastChar;
							string baiduMsg = string.Format( "#*#{0}#*#{1}",qiniuFileName ,obj );
//							TipManager.AddTip("语音转文字:" + baiduMsg);
							string tempMsg= ChatModel.Instance.PieceTypeAndContent( ChatMessageFunctionType.VoiceTalk , baiduMsg );
							//TipManager.AddTip(tempMsg);
							if( callBackTalkTranslate != null && isTimeOutDic[time] == false)
							{
								isReceiveDic[time] = true;
//								TipManager.AddTip("10秒内返回了");
								callBackTalkTranslate( tempMsg );

								//重置为false初始状态
								FingersDragOver();
							}
						});
					}
					
					//TipManager.AddWhiteTip("录音结束");
				} ) ;
			}
			else{
//				TipManager.AddTip("已取消发送");
			}

			}

	}
	#endregion
	
		
	public void DelTalkCache()
	{
		string path = Application.persistentDataPath + "/talk/";
		if(Directory.Exists(path))
		{
			Directory.Delete(path,true);
		}
	}
}

public class VoiceKeyDelegate
{
	public System.Action< byte[],int,string > _callBackFinish;

	public AudioClip _recondClip = null;

	public void GetKeyThread( Action< byte[],int,string > callBackFinish , AudioClip recondClip )
	{
		_callBackFinish = callBackFinish;

		_recondClip = recondClip;

		Thread thread = new Thread( new ThreadStart( GetKeyWork ) );
		thread.Start();

		
	}

	public void GetKeyWork()
	{
		// debug TipManager.AddTip("压缩 wav 文件成为 amrBuf");

		byte[] wavBuf = SavWav.ToWav( _recondClip );
		// wav to amr
		byte[] amrBuf = new byte[wavBuf.Length];
		int amrSize = (int)HzamrPlugin.WavToAmr(wavBuf,wavBuf.Length,amrBuf);
		//TipManager.AddTip("压缩完成");
		if( amrSize > 0 )
		{
			// debug TipManager.AddTip("压缩成功");
			if( _callBackFinish != null )
			{
				_callBackFinish(amrBuf,amrSize,VoiceRecognitionManager.Instance.SaveVoiceToQiniu(amrBuf ,amrSize));
			}

		}
	}
}

	